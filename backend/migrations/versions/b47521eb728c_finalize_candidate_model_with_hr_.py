"""Finalize candidate model with hr_comments and ensure constraints

Revision ID: b47521eb728c
Revises: cbb350fd4970
Create Date: 2025-05-14 18:15:02.948951

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
from datetime import datetime, timezone as dt_timezone

# revision identifiers, used by Alembic.
revision = 'b47521eb728c'
down_revision = 'cbb350fd4970'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - ADJUSTED ###

    # Βήμα 1: Προσωρινή αφαίρεση του foreign key constraint από το association table
    try:
        op.drop_constraint('fk_candidate_position_association_candidate_id_candidates',
                           'candidate_position_association', type_='foreignkey')
        print(
            "SUCCESS: Dropped FK 'fk_candidate_position_association_candidate_id_candidates' from 'candidate_position_association'.")
    except Exception as e:
        print(
            f"INFO: Could not drop FK 'fk_candidate_position_association_candidate_id_candidates' (it might not exist or other issue): {e}")

    # Βήμα 2: Αλλαγή τύπου στον πίνακα 'candidates'
    with op.batch_alter_table('candidates', schema=None) as batch_op:
        batch_op.add_column(sa.Column('hr_comments', sa.Text(), nullable=True))
        batch_op.alter_column('candidate_id',
                              existing_type=sa.VARCHAR(length=36),
                              type_=postgresql.UUID(as_uuid=True),
                              existing_nullable=False,
                              postgresql_using='candidate_id::uuid')
        batch_op.alter_column('email',
                              existing_type=sa.VARCHAR(length=255),
                              type_=sa.String(length=120),
                              existing_nullable=True)
        batch_op.alter_column('submission_date',
                              existing_type=postgresql.TIMESTAMP(timezone=True),
                              type_=sa.DateTime(),
                              existing_nullable=True)
        batch_op.alter_column('updated_at',
                              existing_type=postgresql.TIMESTAMP(timezone=True),
                              type_=sa.DateTime(),
                              existing_nullable=True)
        batch_op.alter_column('interviewers',
                              existing_type=postgresql.JSON(astext_type=sa.Text()),
                              type_=postgresql.JSONB(astext_type=sa.Text()),
                              existing_nullable=True,
                              server_default='[]')
        batch_op.alter_column('offers',
                              existing_type=postgresql.JSON(astext_type=sa.Text()),
                              type_=postgresql.JSONB(astext_type=sa.Text()),
                              existing_nullable=True,
                              server_default='[]')
        batch_op.alter_column('confirmation_uuid',
                              existing_type=sa.VARCHAR(length=36),
                              type_=postgresql.UUID(as_uuid=True),
                              nullable=False,
                              postgresql_using='confirmation_uuid::uuid')
        batch_op.alter_column('candidate_confirmation_status',
                              existing_type=sa.VARCHAR(length=50),
                              type_=sa.String(length=20),
                              existing_nullable=True)
        batch_op.alter_column('history',
                              existing_type=postgresql.JSON(astext_type=sa.Text()),
                              type_=postgresql.JSONB(astext_type=sa.Text()),
                              existing_nullable=True,
                              server_default='[]')
        # Το foreign key 'fk_candidates_company_id_companies' αναφέρεται στο companies.id σύμφωνα με το \d companies.
        # Αν το μοντέλο Candidate έχει company_id = db.Column(db.Integer, db.ForeignKey('companies.company_id'), ...)
        # και το Company model έχει company_id = db.Column(db.Integer, primary_key=True),
        # τότε το FK στο migration θα έπρεπε να είναι ['company_id'], ['company_id'].
        # Αλλά το \d companies έδειξε ότι το PK είναι 'id'. Άρα το FK του Candidate στη βάση *πρέπει* να δείχνει στο 'companies.id'.
        # Εδώ δεν κάνουμε create_foreign_key, οπότε το αφήνουμε ως έχει, υποθέτοντας ότι το υπάρχον FK είναι σωστό.
        # Αν το FK 'fk_candidates_company_id_companies' έπρεπε να αλλάξει, θα χρειαζόταν drop και recreate.

    # Βήμα 3: Αλλαγή τύπου στον πίνακα 'candidate_position_association'
    with op.batch_alter_table('candidate_position_association', schema=None) as batch_op:
        batch_op.alter_column('candidate_id',
                              existing_type=sa.VARCHAR(length=36),
                              type_=postgresql.UUID(as_uuid=True),
                              existing_nullable=False,
                              postgresql_using='candidate_id::uuid')

    # Βήμα 4: Επαναδημιουργία του foreign key constraint για το association table
    op.create_foreign_key(
        'fk_candidate_position_association_candidate_id_candidates',
        'candidate_position_association', 'candidates',
        ['candidate_id'], ['candidate_id'],  # Αυτό είναι σωστό, αναφέρεται στο candidates.candidate_id
        ondelete='CASCADE'
    )
    print("SUCCESS: Re-created FK 'fk_candidate_position_association_candidate_id_candidates'.")

    # --- Πίνακας companies ---
    with op.batch_alter_table('companies', schema=None) as batch_op:
        batch_op.add_column(sa.Column('industry', sa.String(length=120), nullable=True))
        batch_op.alter_column('created_at',
                              existing_type=postgresql.TIMESTAMP(timezone=True),
                              type_=sa.DateTime(),
                              existing_nullable=True)
        batch_op.alter_column('updated_at',
                              existing_type=postgresql.TIMESTAMP(timezone=True),
                              type_=sa.DateTime(),
                              existing_nullable=True)
        try:
            # Το \d companies έδειξε ότι το unique constraint στο name είναι 'ix_companies_name'
            # Αντί να το δημιουργήσουμε, ας υποθέσουμε ότι υπάρχει ήδη σωστά.
            # Αν θέλαμε να το μετονομάσουμε ή να βεβαιωθούμε, θα χρειαζόταν πρώτα drop του 'ix_companies_name'
            # και μετά create του 'uq_companies_name'.
            # Για τώρα, ας μην το πειράξουμε αν το 'ix_companies_name' εξυπηρετεί τον σκοπό.
            # batch_op.create_unique_constraint('uq_companies_name', ['name'])
            # print("INFO: Ensured unique constraint 'uq_companies_name' on companies.name.")
            print(
                "INFO: Skipping creation of unique constraint 'uq_companies_name' on companies.name, assuming 'ix_companies_name' exists.")
        except Exception as e:
            print(
                f"INFO: Could not create unique constraint 'uq_companies_name' (possibly already exists or other issue): {e}")

    # --- Υπόλοιποι Πίνακες (company_settings, positions, users) ---
    with op.batch_alter_table('company_settings', schema=None) as batch_op:
        batch_op.alter_column('default_interview_reminder_timing_minutes',
                              existing_type=sa.INTEGER(),
                              nullable=True,  # Το \d έδειξε not null, default 60. Αλλά το model έχει default 1440.
                              # Ας το κάνουμε nullable=True για να επιτρέψουμε την αλλαγή του server_default.
                              server_default=sa.text('1440'))
        batch_op.alter_column('enable_reminders_feature_for_company',
                              existing_type=sa.BOOLEAN(),
                              nullable=True,  # Το \d έδειξε not null, default true.
                              server_default=sa.text('true'))
        try:
            # Το \d company_settings έδειξε ότι το FK υπάρχει ήδη και λέγεται 'fk_company_settings_company_id_companies'
            # και αναφέρεται σωστά στο companies(id).
            batch_op.drop_constraint('fk_company_settings_company_id_companies', type_='foreignkey')
            print("SUCCESS: Dropped existing FK 'fk_company_settings_company_id_companies'.")
        except Exception as e:
            print(f"INFO: Could not drop fk_company_settings_company_id_companies: {e}")

        batch_op.create_foreign_key('fk_company_settings_company_id_companies',  # Όνομα constraint
                                    'companies',  # Πίνακας αναφοράς
                                    ['company_id'],  # Τοπική στήλη (company_settings.company_id)
                                    ['id'],  # Στήλη αναφοράς στον companies (ΑΛΛΑΓΗ ΕΔΩ)
                                    ondelete='CASCADE')
        print("SUCCESS: Re-created FK 'fk_company_settings_company_id_companies' referencing companies.id.")

    with op.batch_alter_table('positions', schema=None) as batch_op:
        batch_op.alter_column('position_name', existing_type=sa.VARCHAR(length=255), type_=sa.String(length=150),
                              existing_nullable=False)
        batch_op.alter_column('status', existing_type=sa.VARCHAR(length=50), nullable=True,
                              server_default=sa.text("'Open'"))
        batch_op.alter_column('created_at', existing_type=postgresql.TIMESTAMP(timezone=True), type_=sa.DateTime(),
                              existing_nullable=True)
        batch_op.alter_column('updated_at', existing_type=postgresql.TIMESTAMP(timezone=True), type_=sa.DateTime(),
                              existing_nullable=True)
        try:
            # Πρέπει να δούμε αν υπάρχει unique constraint 'uq_positions_position_name_company_id' ή παρόμοιο από το \d positions
            # Αν υποθέσουμε ότι θέλουμε να εξασφαλίσουμε το 'uq_position_name_company_id':
            # Πρώτα drop αν υπάρχει κάποιο παλιό με άλλο όνομα στις ίδιες στήλες.
            # op.drop_constraint('OLD_UNIQUE_CONSTRAINT_NAME_IF_ANY', type_='unique') # Αν υπήρχε παλιό
            batch_op.drop_constraint('uq_positions_position_name_company_id',
                                     type_='unique')  # Όπως ήταν στο script σου
            print("SUCCESS: Dropped unique constraint 'uq_positions_position_name_company_id' if it existed.")
        except Exception as e:
            print(f"INFO: Could not drop uq_positions_position_name_company_id: {e}")
        batch_op.create_unique_constraint('uq_position_name_company_id', ['position_name', 'company_id'])
        print("SUCCESS: Created unique constraint 'uq_position_name_company_id'.")

        try:
            # Το \d companies έδειξε ότι το positions αναφέρεται σε αυτό με FK 'fk_positions_company_id_companies'
            # και το FK αυτό αναφέρεται στο companies(id).
            batch_op.drop_constraint('fk_positions_company_id_companies', type_='foreignkey')
            print("SUCCESS: Dropped existing FK 'fk_positions_company_id_companies'.")
        except Exception as e:
            print(f"INFO: Could not drop fk_positions_company_id_companies: {e}")

        batch_op.create_foreign_key('fk_positions_company_id_companies',  # Όνομα constraint
                                    'companies',  # Πίνακας αναφοράς
                                    ['company_id'],  # Τοπική στήλη (positions.company_id)
                                    ['id'],  # Στήλη αναφοράς στον companies (ΑΛΛΑΓΗ ΕΔΩ)
                                    ondelete='CASCADE')
        print("SUCCESS: Re-created FK 'fk_positions_company_id_companies' referencing companies.id.")

    with op.batch_alter_table('users', schema=None) as batch_op:
        conn = op.get_bind()
        inspector = sa.inspect(conn)
        columns = [c['name'] for c in inspector.get_columns('users')]

        if 'updated_at' not in columns:
            batch_op.add_column(
                sa.Column('updated_at', sa.DateTime(), nullable=True,
                          default=lambda: datetime.now(dt_timezone.utc),
                          onupdate=lambda: datetime.now(dt_timezone.utc))
            )
            print("INFO: Added 'updated_at' column to 'users' table.")
        else:
            batch_op.alter_column('updated_at',
                                  existing_type=postgresql.TIMESTAMP(timezone=True),
                                  type_=sa.DateTime(),
                                  existing_nullable=True
                                  )
            print("INFO: Altered 'updated_at' column in 'users' table.")

        batch_op.alter_column('role', existing_type=sa.VARCHAR(length=50), type_=sa.String(length=20),
                              existing_nullable=False, server_default=sa.text("'user'"))
        batch_op.alter_column('is_active', existing_type=sa.BOOLEAN(), nullable=True, server_default=sa.text('true'))
        batch_op.alter_column('created_at', existing_type=postgresql.TIMESTAMP(timezone=True), type_=sa.DateTime(),
                              existing_nullable=True)
        batch_op.alter_column('enable_email_interview_reminders', existing_type=sa.BOOLEAN(), nullable=True,
                              server_default=sa.text('true'))
        batch_op.alter_column('interview_reminder_lead_time_minutes', existing_type=sa.INTEGER(), nullable=True,
                              server_default=sa.text('60'))
        try:
            # Το \d companies έδειξε ότι το users αναφέρεται σε αυτό με FK 'fk_users_company_id_companies'
            # και το FK αυτό αναφέρεται στο companies(id).
            batch_op.drop_constraint('fk_users_company_id_companies', type_='foreignkey')
            print("SUCCESS: Dropped existing FK 'fk_users_company_id_companies'.")
        except Exception as e:
            print(f"INFO: Could not drop fk_users_company_id_companies: {e}")

        batch_op.create_foreign_key('fk_users_company_id_companies',  # Όνομα constraint
                                    'companies',  # Πίνακας αναφοράς
                                    ['company_id'],  # Τοπική στήλη (users.company_id)
                                    ['id'])  # Στήλη αναφοράς στον companies (ΑΛΛΑΓΗ ΕΔΩ)
        # Το ondelete δεν υπήρχε στο \d companies για αυτό το FK, οπότε το αφήνουμε έτσι.
        # users.company_id είναι nullable, οπότε το default ON DELETE είναι NO ACTION ή RESTRICT.
        print("SUCCESS: Re-created FK 'fk_users_company_id_companies' referencing companies.id.")

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - PLEASE ADJUST! ###
    pass
    # Η πλήρης υλοποίηση του downgrade θα απαιτούσε την αντιστροφή όλων αυτών των βημάτων,
    # συμπεριλαμβανομένης της επαναφοράς των foreign keys ώστε να δείχνουν στο 'company_id'
    # αν αυτή ήταν η πρόθεση για τα μοντέλα.
    # Για τώρα, το pass είναι αρκετό για να μην έχουμε IndentationError.

    # Παράδειγμα για company_settings (αντίστροφο):
    # with op.batch_alter_table('company_settings', schema=None) as batch_op:
    #     batch_op.drop_constraint('fk_company_settings_company_id_companies', type_='foreignkey')
    #     # Εδώ θα έπρεπε να ξαναδημιουργηθεί το FK δείχνοντας στο companies.company_id (αν αυτό ήταν το σωστό)
    #     # ή στο companies.id αν το downgrade δεν αλλάζει το PK του companies.
    #     # Αυτό εξαρτάται από το τι θέλουμε να κάνει το downgrade.
    #     batch_op.create_foreign_key('fk_company_settings_company_id_companies_original', # Ίσως παλιό όνομα
    #                                 'companies',
    #                                 ['company_id'],
    #                                 ['company_id'], # Αν υποθέσουμε ότι το PK του companies ξαναγίνεται company_id
    #                                 ondelete='CASCADE')
    #     batch_op.alter_column('enable_reminders_feature_for_company', server_default=sa.text('true'), nullable=False) # Επαναφορά not null
    #     batch_op.alter_column('default_interview_reminder_timing_minutes', server_default=sa.text('60'), nullable=False) # Επαναφορά not null

    # ... και ούτω καθεξής για τους άλλους πίνακες ...

    # ### end Alembic commands ###